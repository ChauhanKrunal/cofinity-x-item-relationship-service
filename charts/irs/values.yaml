# Default values for irs.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: ghcr.io/catenax-ng/irs-api
  pullPolicy: Always

imagePullSecrets: [ ]

podAnnotations: { }

# -- The [pod security context](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod) defines privilege and access control settings for a Pod within the deployment
podSecurityContext:
  seccompProfile:
    type: RuntimeDefault

# Following Catena-X Helm Best Practices @url: https://catenax-ng.github.io/docs/kubernetes-basics/helm
# @url: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
securityContext:
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  runAsNonRoot: true
  runAsUser: 10000
  runAsGroup: 3000

service:
  type: ClusterIP
  port: 8080
  actuatorPort: 4004

autoscaling:
  enabled: false

# Following Catena-X Helm Best Practices @url: https://catenax-ng.github.io/docs/kubernetes-basics/helm
# @url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-resource-requests-and-limits
resources:
  limits:
    cpu: 0.75
    memory: 1.5Gi
  requests:
    cpu: 250m
    memory: 512Mi

nodeSelector: { }

tolerations: [ ]

# Following Catena-X Helm Best Practices @url: https://catenax-ng.github.io/docs/kubernetes-basics/helm
# @url: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: DoesNotExist
          topologyKey: kubernetes.io/hostname

# Following Catena-X Helm Best Practices @url: https://catenax-ng.github.io/docs/kubernetes-basics/helm
# @url: https://github.com/helm/charts/blob/master/stable/nginx-ingress/values.yaml#L210
livenessProbe:
  failureThreshold: 6
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 1
readinessProbe:
  failureThreshold: 3
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 1

######################
# Application config #
######################
global:
  enablePrometheus: false #<1>
  enableGrafana: false #<1>
#####################
# IRS Configuration #
#####################
irsUrl: "https://<irs-url>"
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/ssl-passthrough: "false"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
  hosts:
    - host: "<irs-url>"
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls:
    - hosts:
        - "<irs-url>"
      secretName: tls-secret
digitalTwinRegistry:
  url: https://<digital-twin-registry-url>
semanticsHub:
  url: https://<semantics-hub-url>
  defaultUrns: >
    urn:bamm:io.catenax.serial_part_typization:1.0.0#SerialPartTypization
#    ,urn:bamm:com.catenax.assembly_part_relationship:1.0.0#AssemblyPartRelationship
bpdm:
  url: https://<bpdm-url>
minioUser: <minio-username>
minioPassword: <minio-password>
keycloak:
  oauth2:
    clientId: <keycloak-client-id>
    clientSecret: <keycloak-client-secret>
    clientTokenUri: <keycloak-token-uri>
    jwkSetUri: <keycloak-jwkset-uri>
edc:
  controlplane:
    endpoint:
      data:
    request:
      ttl: PT10M
    provider:
      suffix: /api/v1/ids/data
    catalog:
      limit: 1000
    apikey:
      header:
      secret: test
  submodel:
    request:
      ttl: PT10M
    path: /submodel
    urnprefix: /urn


#######################
# Minio Configuration #
#######################
irs-minio:
  minioUser: <minio-username>
  minioPassword: <minio-password>

#########################
# Grafana Configuration #
#########################
irs-grafana:  #<2>
  ingress:
    hosts:
      - host: "<grafana-url>"
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls:
      - hosts:
          - "<grafana-url>"
        secretName: tls-secret

    username: <grafana-username>
    password: <grafana-password>

##############################
# EDC Postgres Configuration #
##############################
postgresql:
  auth:
    username: <postgres-username>
    database: <postgres-database>
    postgresPassword: <postgres-admin-password>
    password: <postgres-password>

##################################
# EDC Controlplane Configuration #
##################################
edc-controlplane:
  ingresses:
    - enabled: true
      hostname: "<controlplane-url>"
      annotations:
        nginx.ingress.kubernetes.io/ssl-passthrough: "false"
        nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
        nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      endpoints:
        - ids
        - data
      className: ""
      tls:
        - hosts:
            - "<controlplane-url>"
          secretName: tls-secret
      certManager:
        issuer: ""
        clusterIssuer: ""

  edc:
    postgresql:
      user: <postgres-username>
      password: <postgres-password>
    transfer:
      proxy:
        token:
          verifier:
            publickey:
              alias: <daps-certificate-name>
          signer:
            privatekey:
              alias: <daps-privatekey-name>
    api:
      auth:
        key: "<edc-api-key>"
    controlplane:
      url: "https://<controlplane-url>"
    dataplane:
      url: "https://<dataplane-url>"
  configuration:
    properties: |-
      edc.oauth.client.id=<daps-client-id>
      edc.oauth.private.key.alias=<daps-privatekey-name>
      edc.oauth.provider.jwks.url=<daps-jwks-url>
      edc.oauth.public.key.alias=<daps-certificate-name>
      edc.oauth.token.url=<daps-token-url>
      edc.vault.hashicorp.url=<vault-url>
      edc.vault.hashicorp.token=<vault-token>
      edc.vault.hashicorp.api.secret.path=<vault-secret-store-path>
      edc.data.encryption.keys.alias=<daps-privatekey-name>
      edc.data.encryption.algorithm=NONE

###############################
# EDC Dataplane Configuration #
###############################
edc-dataplane:
  edc:
    api:
      auth:
        key: "<edc-api-key>"
  ## Ingress declaration to expose the network service.
    ingresses:
      - enabled: true
        hostname: "<dataplane-url>"
        annotations:
          nginx.ingress.kubernetes.io/ssl-passthrough: "false"
          nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
          nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        endpoints:
          - public
        className: "nginx"
        tls:
          - hosts:
              - "<dataplane-url>"
            secretName: tls-secret
        certManager:
          issuer: ""
          clusterIssuer: "

    configuration:
      properties: |-
        edc.oauth.client.id=<daps-client-id>
        edc.oauth.private.key.alias=<daps-privatekey-name>
        edc.oauth.provider.audience=idsc:IDS_CONNECTORS_ALL
        edc.oauth.provider.jwks.url=<daps-jwks-url>
        edc.oauth.public.key.alias=<daps-certificate-name>
        edc.oauth.token.url=<daps-token-url>
        edc.vault.hashicorp.url=<vault-url>
        edc.vault.hashicorp.token=<vault-token>
        edc.vault.hashicorp.api.secret.path=<vault-secret-store-path>